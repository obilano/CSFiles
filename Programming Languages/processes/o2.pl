#!/usr/bin/perl

use IO::Handle;
pipe(I1, O1);
pipe(I2, O2);
O1->autoflush(1);
O2->autoflush(1);

#acccept three command-line arguments
die("Usage: argv.pl startRange endRange coundOfRand") if (@ARGV != 3);

$startRange= $ARGV[0];
$endRange = $ARGV[1];
$countOfRand = $ARGV[2];

for $i (0..3)
{
  $ids[$i]=fork();
  if ($ids[$i]==0)
  {		
	#call sub-child process
	&child;
  }
  else
  {	
	# Parent read input data from child through pipe
	$childSum = <I2>;
    	$childMean = $childSum / $countOfRand;
	$childrenMean += $childMean;
  }	 	
}

#Parent process
$globalMean = $childrenMean / 4;
#display report heading
printf("\nRange of numbers:\t\t   %.0d through %.0d\n", $ARGV[0], $ARGV[1]);
printf("Numbers generated by each process:\t%0.d\n", $ARGV[2]); 
printf("Global Mean (rounded to nearest tenth):\t%.1f\n\n", $globalMean);
print "Analysis compared to the global mean:\n\n";
print "Process\t   PID\t   Mean\t   Below   Above\n";
print "-------\t  -----\t   -----   -----   -----\n";
#wait for child to finish process
foreach $i (0..3)
{	#write the global mean to child through pipe
	print O1 "$globalMean\n";
	$x = wait;
}

#Child process
sub child
{	
	my @rand = ();
	foreach $j (0..$countOfRand-1)
  	{	#generate random numbers
		$rand[$j] = int($startRange + rand($endRange - $startRange + 1));	
		$sum += $rand[$j];	
 	} 
	#child write the sum to parent through pipe
	print O2 "$sum\n";
	$mean = $sum / $countOfRand;
	#read global mean from parent through pipe
	$globMean = <I1>;
	#compare the numbers to global mean
	foreach $k (0..$countOfRand-1)
	{
		if($rand[$k] > $globMean){ $above++;}
		if($rand[$k] < $globMean){ $below++;}
	}
	sleep (2+rand(2));
	#diplay statistic of each child
	printf("%3d\t  %5d\t   %5.1f   %3d\t   %3d\n", $i, $$, $mean, $below, $above);	
  	exit;	
}



